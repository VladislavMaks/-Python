# 1) Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()),
# который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц вы найдете в методичке.
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса
# Matrix (двух матриц). Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем
# с первым элементом первой строки второй матрицы и т.д.

class Matrix:

    def __init__(self, list_of_lists):
        self.list_of_lists = list_of_lists

    def __str__(self):
        for item in self.list_of_lists:
            for i in item:
                print(f"{i:3}", end="")
            print()
        return ''

    def __add__(self, other):
        for i in range(len(self.list_of_lists)):
            for i_2 in range(len(other.list_of_lists[i])):
                self.list_of_lists[i][i_2] = self.list_of_lists[i][i_2] + other.list_of_lists[i][i_2]
        return Matrix.__str__(self)

matrix = Matrix([
    [2, 3, 4, 5],
    [1, 0, 8, 6],
    [1, 0, 8, 6]
])
another_matrix = Matrix([
    [2, 3, 4, 5],
    [1, 0, 8, 6],
    [1, 0, 8, 6]
])

print(matrix + another_matrix)


# 2) Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность (класс) этого
# проекта — одежда, которая может иметь определенное название. К типам одежды в этом проекте относятся пальто и костюм.
# У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа:
# V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5),
# для костюма (2 * H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания:
# реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.

from abc import ABC, abstractmethod


class Clothes(ABC):

    def __init__(self, name, size, height):
        self.name = name
        self.size = size
        self.height = height

    @abstractmethod
    def get_sum_consumption(self):
        pass


class Coat(Clothes):

    @property
    def get_coat_consumption(self):
        consumption = self.size / 6.5 + 0.5
        return f'Для пошивки {self.name} размером {self.size} необходимо {consumption} ткани'

    def get_sum_consumption(self):
        return 'Некий абстрактный метод для Coat'


class Suit(Clothes):

    @property
    def get_suit_consumption(self):
        consumption = self.height * 2 + 0.3
        return f'Для пошивки {self.name} размером {self.height} см необходимо {consumption} ткани'

    def get_sum_consumption(self):
        return 'Некий абстрактный метод для Suit'


a = Coat('пальто', 50, 165)
b = Suit('костюма', 50, 165)

print(a.get_coat_consumption)
print(a.get_sum_consumption())
print(b.get_suit_consumption)
print(b.get_sum_consumption())


# 3) Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка. В его конструкторе
# инициализировать параметр, соответствующий количеству клеток (целое число). В классе должны быть реализованы методы
# перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()),
# деление (__truediv__()).Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение,
# умножение и обычное (не целочисленное) деление клеток, соответственно. В методе деления должно осуществляться
# округление значения до целого числа.
# Сложение.Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание.Участвуют две клетки. Операцию необходимо выполнять только
# если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества
# ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление
# количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса
# и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку:
# *****\n*****\n**. Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order()
# вернет строку: *****\n*****\n*****.

class Cell:

    def __init__(self, number):
        self.number = int(number)

    def __add__(self, other):
        return Cell(self.number + other.number)

    def __sub__(self, other):
        residual = self.number - other.number
        return residual if residual > 0 else 'Разность количества ячеек двух клеток меньше нуля'

    def __mul__(self, other):
        return self.number * other.number

    def __truediv__(self, other):
        return self.number // other.number

    def __str__(self):
        return f'{self.number}'

    def make_order(self, cell_numb):
        my_string = ''
        for i in range(int(self.number / cell_numb)):
            my_string += '*' * cell_numb + '\n'
        my_string += '*' * (self.number % cell_numb)
        return my_string


a = Cell(15)
b = Cell(5)
print(a + b)
print(a - b)
print(a * b)
print(a / b)
print(a.make_order(4))


